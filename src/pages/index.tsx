import Head from 'next/head';
import { useState, useEffect } from 'react';
import styles from '@/styles/Home.module.css';
import SignMessage from '@/components/signButton';
import ConnectWallet from '@/components/connectButton';
import {SignMessageProps} from '@/components/signButton';
import ExecuteTransaction from '@/components/executeTransaction';
import {getContractFunctions, Selectors} from '@/hooks/get_contract_functions';
import {multisigABI} from '@/hooks/constants';
import {Provider, hash} from 'starknet';

export default function Home() {
  const [toAddress, setToAddress] = useState('');
  const [signedMessages, setSignedMessages] = useState<SignMessageProps[]>([]);
  const [selectedMessage, setSelectedMessage] = useState<SignMessageProps>();
  const [verifyingContract, setVerifyingContract] = useState('0x06d324601b008ba0393e541a3b8f4aab5b9c07a2298f5175d316664ae863728f');
  const [selectedIndex, setSelectedIndex] = useState<number | null>(null);
  const [contractSelectors, setContractSelectors] = useState<string[]>([]);
  const [contractFunctions, setContractFunctions] = useState<Selectors[]>([]);
  const [selectedFunction, setSelectedFunction] = useState<string>('');
  const [calldata, setCalldata] = useState<string[]>([]);
  const [calldataNames, setCalldataNames] = useState<string[]>([]);
  const [isProxy, setIsProxy] = useState(false);
  const [implementationHash, setImplementationHash] = useState('');
  const [multisigNonce, setMultisigNonce] = useState(0);

  const provider = new Provider({ rpc: { nodeUrl: process.env.NEXT_PUBLIC_INFURA! } });

  const handleContractAddressChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const address = e.target.value;
    setToAddress(address);

    let functions: Selectors[] = [];
    let names: string[] = [];
    if (!implementationHash) {
      functions = await getContractFunctions(provider,address);
      functions.forEach(selector => {
        names.push(selector.name)
      });
    }
    setContractFunctions(functions);
    setContractSelectors(names);
  };

  const handleContractHashChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const address = e.target.value;
    setImplementationHash(address);

    let functions = await getContractFunctions(provider,address);
    let names: string[] = [];
    functions.forEach(selector => {
      names.push(selector.name)
    });
    setContractFunctions(functions);
    setContractSelectors(names);
  };

  const renderInputFields = () => {
    if (!selectedFunction) return null;
  
    const selectedFunctionData = contractFunctions.find(
      (func) => func.name === selectedFunction
    );
  
    if (!selectedFunctionData) return null;
  
    let editedFunctionData:Selectors = {name: selectedFunctionData.name, inputs: []};
    // if an selectedFunctionData entry has the type 'uint256' then we add an additional entry with the name "high" and the type "uint256"
    selectedFunctionData.inputs.forEach((input, index) => {
      if (input.type === 'Uint256') {
        editedFunctionData.inputs.push(input);
        editedFunctionData.inputs.push({name: 'high', type: 'Uint256'});
      }else{
        editedFunctionData.inputs.push(input);
      }
    });

    return editedFunctionData.inputs.map((input, index) => {
      return (
        <div className={styles.inputGroup} key={index}>
          <input
            type="text"
            id={input.name}
            placeholder={`${input.name}, ${input.type}`}
            onChange={(e) => {
              calldata[index] = e.target.value;
              setCalldata(calldata);
            }}
          />
        </div>
      );
    });
  };
  
  useEffect(() => {
    provider.getNonceForAddress(verifyingContract).then((nonce) => {
      setMultisigNonce(Number(nonce));
    });

    if (!selectedFunction) {
      setCalldataNames([]);
      return;
    }
    
    const selectedFunctionData = contractFunctions.find(
      (func) => func.name === selectedFunction
    );
  
    if (!selectedFunctionData) {
      setCalldataNames([]);
    } else {
      //for each selectedFunctionData input entry, if the type is 'uint256' then we add an additional entry with the name "high" and the type "uint256"
      let inputNames: string[] = [];
      selectedFunctionData.inputs.forEach((input, index) => {
        if (input.type === 'Uint256') {
          inputNames.push(input.name);
          inputNames.push('high');
        }else{
          inputNames.push(input.name);
        }
      });
      setCalldataNames(inputNames);
    }
  }, [selectedFunction, contractFunctions]);

  return (
    <>
      <Head>
        <title>Create Next App</title>
        <meta name="description" content="Generated by create next app" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <main className={styles.main}>
        <h1 className={styles.title}>Multisig: {verifyingContract}</h1>
        <div className={styles.connectWalletContainer}>
          <ConnectWallet />
        </div>
        <div className={styles.cardContainer}>
          <div className={styles.leftCard}>
              <h2 className={styles.cardHeading}>Contract Interaction</h2>
              <div className={styles.inputGroup}>
                <input
                  type="text"
                  id="toAddress"
                  placeholder={"Contract Address"}
                  value={toAddress}
                  onChange={handleContractAddressChange}
                />
              </div>
              {isProxy && (
                <div className={styles.inputGroup}>
                  <input
                    type="text"
                    id="implementationHash"
                    placeholder={"Implementation Hash"}
                    value={implementationHash}
                    onChange={handleContractHashChange}
                  />
                </div>
              )}
              <div className={styles.inputGroup}>
                <label htmlFor="isProxy" className={styles.checkboxLabel}>
                  <input
                    type="checkbox"
                    id="isProxy"
                    checked={isProxy}
                    onChange={(e) => setIsProxy(e.target.checked)}
                  />
                  <span>is Proxy</span>
                </label>
              </div>
              <div className={styles.inputGroup}>
                <select
                  value={selectedFunction}
                  onChange={(e) => setSelectedFunction(e.target.value)}
                >
                  {contractSelectors.map((func, index) => (
                    <option key={index} value={func}>
                      {func}
                    </option>
                  ))}
                </select>
              </div>
              {renderInputFields()}
              <SignMessage
                contract_address={toAddress}
                selector={selectedFunction}
                nonce={multisigNonce}
                calldataNames={calldataNames}
                calldata={calldata}
                verifyingContract={verifyingContract}
                onSign={(message) => setSignedMessages([...signedMessages, message])}
              />
          </div>
          <div className={styles.rightCard}>
            <div className={styles.tableContainer}>
              <table className={styles.Table}>
                <thead>
                  <tr>
                    <th>Contract</th>
                    <th>Function</th>
                    <th>CallData</th>
                    <th>Signatures</th>
                    <th>Nonce</th>
                  </tr>
                </thead>
                <tbody>
                  {signedMessages.map((message, index) => (
                    <tr
                      key={index}
                      className={`${styles.tr} ${selectedIndex === index ? styles.highlighted : ''}`}
                      onClick={() => {
                        setSelectedIndex(index);
                        setSelectedMessage({
                          contract_address: message.contract_address,
                          selector: message.selector,
                          calldata: message.calldata,
                          signatures: message.signatures,
                        });
                      }}
                    >
                      <td>
                        <span>{message.contract_address}</span>
                      </td>
                      <td>
                        <span>{message.selector}</span>
                      </td>
                      <td>
                        <div>
                          {message.calldata.map((data, index) => (
                            <span key={index}>
                              {data}
                              <br/>
                            </span>
                          ))}
                        </div>
                      </td>
                      <td>
                        <div>
                          <span>{"s: "+message.signatures[0]}</span>
                          <br/>
                          <span>{"r: "+message.signatures[1]}</span>
                          <br/>
                          <span>{"v: "+message.signatures[2]}</span>
                        </div>
                      </td>
                      <td>
                        <span>{multisigNonce}</span>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
            <ExecuteTransaction
              contract_address={
                //only the first 42 characters of verifyingContract are needed
                verifyingContract.substring(0, 42)
              }
              abi={multisigABI}
              calldata={selectedMessage}
            />
          </div>
        </div>
      </main>
    </>
  );
}
